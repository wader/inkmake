#!/usr/bin/env ruby
#
# inkmake - Makefile inspired export from SVG files using Inkscape as backend
#           with some added smartness.
#
# Copyright (c) 2011 <mattias.wadman@gmail.com>
#
# MIT License:
# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the "Software"), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
# THE SOFTWARE.
#
# Try to stay campatible with Ruby 1.8.7 as its the default ruby
# version included in Mac OS X (at least Lion).
#
# NOTE: Rotation is done using a temporary SVG file that translate and rotate
# a double resolution bitmap and export as a bitmap to the correct resolution.
# This hack is done to get around that Inkscape cant set bitmap oversampling
# mode per file or from command line, default is 2x2 oversampling.
#

require 'csv'
require 'rexml/document'
require 'open3'
require 'optparse'
require 'fileutils'
require 'tempfile'
require 'uri'

class InkscapeUnit
  # 90dpi as reference
  Units = {
    "pt" => 1.25,
    "pc" => 15,
    "mm" => 3.543307,
    "cm" => 35.43307,
    "dm" => 354.3307,
    "m"  => 3543.307,
    "in" => 90,
    "ft" => 1080,
    "uu" => 1 # user unit, 90 dpi
  }

  attr_reader :value, :unit

  def initialize(value, unit="uu")
    case value
    when /^(\d+(?:\.\d+)?)(\w+)?$/ then
      @value = $1.to_f
      @unit = $2
      @unit ||= unit
      @unit = (@unit == "px" or Units.has_key?(@unit)) ? @unit : "uu"
    else
      @value = value.kind_of?(String) ? value.to_f: value
      @unit = unit
    end
  end

  def to_pixels(dpi=90.0)
    return @value.round if @unit == "px"
    ((dpi / 90.0) * Units[@unit] * @value).round
  end

  def to_s
    "%g#{@unit}" % @value
  end

  def scale(f)
    return self if @unit == "px"
    InkscapeUnit.new(@value * f, @unit)
  end
end

class InkscapeResolution
  attr_reader :width, :height

  def initialize(width, height, unit="uu")
    @width = width.kind_of?(InkscapeUnit) ? width : InkscapeUnit.new(width, unit)
    @height = height.kind_of?(InkscapeUnit) ? height : InkscapeUnit.new(height, unit)
  end

  def scale(f)
    InkscapeResolution.new(@width.scale(f), @height.scale(f))
  end
  
  def to_s
    "#{@width.to_s}x#{@height.to_s}"
  end
end

class InkscapeRemote
  def initialize
    @in, @out, @err = Open3.popen3("\"#{InkscapeRemote.escape(self.class.path)}\" --shell")
    loop do
      case response
      when :prompt then break
      end
    end
    yield self
  ensure
    quit
  end

  def command(args)
    c = args.collect do |key, value|
      if value
        "\"#{key}=#{self.class.escape value.to_s}\""
      else
        key
      end
    end.join(" ")
    puts "> #{c}" if $verbose
    @in.write "#{c}\n"
    @in.flush
  end

  def response
    o = @out.read(1)
    if o == ">"
      puts "< #{o}" if $verbose
      return :prompt;
    end
    o = o + @out.readline
    puts "< #{o}" if $verbose
    o
  end
  
  def export(opts)
    c = {
      "--file" => opts[:svg_path],
      "--export-#{opts[:format]}" => opts[:out_path]
    }
    if opts[:res]
      s = opts[:rotate_scale_hack] ? 2 : 1
      c["--export-width"] = opts[:res].width.to_pixels(opts[:dpi] || 90) * s
      c["--export-height"] = opts[:res].height.to_pixels(opts[:dpi] || 90) * s
    end
    if opts[:dpi]
      c["--export-dpi"] = opts[:dpi]
    end
    if opts[:area].kind_of? Array
      c["--export-area"] = "%f:%f:%f:%f" % opts[:area]
    elsif opts[:area] == :drawing
      c["--export-area-drawing"] = nil
    elsif opts[:area].kind_of? String
      c["--export-id"] = opts[:area]
    end
    command(c)
    width, height = [0, 0]
    out = nil
    loop do
      case response
      when /^Bitmap saved as: (.*)$/ then
        out = $1
      when /^Area .* exported to (\d+) x (\d+) pixels.*$/ then
        width = $1
        height = $2
      when :prompt then break
      end
    end

    [out, [width, height]]
  end

  def query_all(file)
    ids = []
    command({
      "--file" => file,
      "--query-all" => nil,
    })
    loop do
      case response
      when /^(.*),(.*),(.*),(.*),(.*)$/ then ids << [$1, $2.to_f, $3.to_f, $4.to_f, $5.to_f]
      when :prompt then break
      end
    end
    ids
  end

  def ids(file)
    Hash[query_all(file).map {|l| [l[0], l[1..-1]]}]
  end

  def drawing_area(file)
    query_all(file).first[1..-1]
  end

  def quit
    command({"quit" => nil})
    @out.read
    nil
  end

  def self.escape(s)
    s.gsub(/(["'])/, '\\\\\1')
  end

  def self.path
    return $inkscape_path if defined? $inkscape_path

    # try to figure out inkscape path
    p = (([
          "/Applications/Inkscape.app/Contents/Resources/bin/inkscape",
          'c:\Program Files\Inkscape\inkscape.exe',
          'c:\Program Files (x86)\Inkscape\inkscape.exe'] +
          (ENV['PATH'].split(':').map {|p| File.join(p, "inkscape")})).select do |path|
            File.exists? path
          end).first
    if p
      p
    else
      begin
        require 'osx/cocoa'
        "#{OSX::NSWorkspace.sharedWorkspace.fullPathForApplication:"Inkscape"}/Contents/Resources/bin/inkscape"
      rescue NameError, LoadError
        nil
      end
    end
  end
end

class InkFile
  attr_reader :svg_path, :out_path
  DefaultVariants = {
    "@2x" => {:scale => 2.0}
  }
  Rotations = {
    "right" => 90,
    "left" => -90,
    "upsidedown" => 180
  }
  # 123x123, 12.3cm*12.3cm
  RES_RE = /^(\d+(?:\.\d+)?(?:px|pt|pc|mm|cm|dm|m|in|ft|uu)?)[x*](\d+(?:\.\d+)?(?:px|pt|pc|mm|cm|dm|m|in|ft|uu)?)$/ 
  # *123, *1.23
  SCALE_RE = /^\*(\d+(?:\.\d+)?)$/
  # 180dpi
  DPI_RE = /^(\d+(?:\.\d+)?)dpi$/i
  # (prefix)[(...)](suffix)
  DEST_RE = /^([^\[]*)(?:\[(.*)\])?(.*)$/
  # test.svg, test.SVG
  SVG_RE = /\.svg$/i
  # ext to format, supported inkscape output formats
  EXT_RE = /\.(png|pdf|ps|eps)$/i
  # supported inkscape output formats
  FORMAT_RE = /^(png|pdf|ps|eps)$/i
  # @name
  AREA_NAME_RE=/^@(.*)$/
  # @x:y:w:h
  AREA_SPEC_RE=/^@(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):(\d+(?:\.\d+)?):(\d+(?:\.\d+)?)$/
  # right, left, upsidedown
  ROTATE_RE=/^(right|left|upsidedown)$/

  class SyntaxError < StandardError
  end

  class ProcessError < StandardError
  end

  def initialize(file, opts)
    @file = file
    @images = []
    @force = opts[:force]

    svg_path = nil
    out_path = nil
    File.read(file).lines.each_with_index do |line, index|
      line.strip!
      next if line.empty? or line.start_with? "#"
      begin
        case line
        when /^svg:(.*)/i then svg_path = File.expand_path($1.strip, File.dirname(file))
        when /^out:(.*)/i then out_path = File.expand_path($1.strip, File.dirname(file))
        else
          @images << InkImage.new(self, parse_line(line))
        end
      rescue SyntaxError => e
        puts "#{file}:#{index+1}: #{e.message}"
        exit
      end
    end

    # order is: argument, config in inkfile, inkfile directory
    @svg_path = opts[:svg_path] || svg_path || File.dirname(file)
    @out_path = opts[:out_path] || out_path || File.dirname(file)
  end

  def parse_split_line(line)
    # changed CSV API in ruby 1.9
    if RUBY_VERSION.start_with? "1.8"
      CSV::parse_line(line, fs = " ")
    else
      CSV::parse_line(line, {:col_sep => " "})
    end
  end

  def parse_line(line)
    cols = parse_split_line(line)
    raise SyntaxError, "Invalid number of columns" if cols.count < 1

    if not DEST_RE.match(cols[0])
      raise SyntaxError, "Invalid destination format \"#{cols[0]}\""
    end

    opts = {}
    opts[:prefix] = $1
    variants = $2
    opts[:suffix] = $3
    opts[:format] = $1.downcase if EXT_RE.match(opts[:prefix] + opts[:suffix])

    cols[1..-1].each do |col|
      case col
      when RES_RE then opts[:res] = InkscapeResolution.new($1, $2, "px")
      when SVG_RE then opts[:svg] = col
      when AREA_SPEC_RE then opts[:area] = [$1.to_f, $2.to_f, $3.to_f, $4.to_f]
      when AREA_NAME_RE then opts[:area] = $1
      when /^drawing$/ then opts[:area] = :drawing
      when FORMAT_RE then opts[:format] = $1.downcase
      when ROTATE_RE then opts[:rotate] = Rotations[$1]
      when SCALE_RE then opts[:scale] = $1.to_f
      when DPI_RE then opts[:dpi] = $1.to_f
      else
        raise SyntaxError, "Unknown column \"#{col}\""
      end
    end

    if not opts[:format]
      raise SyntaxError, "Unknown or no output format could be determined"
    end

    variants = (variants.split("|") if variants) || []
    opts[:variants] = variants.collect do |variant|
      name, options = variant.split("=", 2)
      if options
        options = Hash[
          options.split(",").map do |option|
            case option
            when ROTATE_RE then [:rotate, Rotations[$1]]
            when RES_RE then [:res, InkscapeResolution.new($1, $2, "px")]
            when SCALE_RE then [:scale, $1.to_f]
            when DPI_RE then [:dpi, $1.to_f]
            else
              raise SyntaxError, "Invalid variant option \"#{option}\""
            end
          end
        ]
      else
        options = DefaultVariants[name]
        raise SyntaxError, "Invalid default variant \"#{name}\"" if not options
      end

      [name, options]
    end

    opts
  end

  def variants_to_generate
    l = []
    @images.each do |image|
      image.variants.each do |variant|
        next if not @force and 
          File.exists? variant.out_path and
          File.mtime(variant.out_path) > File.mtime(image.svg_path) and
          File.mtime(variant.out_path) > File.mtime(@file)
        if variant.out_path == image.svg_path
          raise ProcessError, "Avoiding overwriting source SVG file #{image.svg_path}"
        end

        l << variant
      end
    end

    l
  end

  def temp_rotate_svg(path, degrees, width, height)
    if degrees != 180
      out_width, out_height = height, width
    else
      out_width, out_height = width, height
    end
    svg = 
      "<?xml version=\"1.0\"?>" +
      "<svg xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"#{out_width}\" height=\"#{out_height}\">" +
      "<g>" +
      "<image transform=\"translate(#{out_width/2} #{out_height/2}) rotate(#{degrees})\"" +
      "  width=\"#{width}\" height=\"#{height}\" x=\"#{-width/2}\" y=\"#{-height/2}\"" +
      "  xlink:href=\"file:///#{URI.escape(path)}\" />" +
      "</g>" +
      "</svg>"
    f = Tempfile.new("inkmake")
    f.write(svg)
    f.seek(0)
    [f, out_width, out_height]
  end

  def process
    variants = variants_to_generate
    if variants.empty?
      return false
    end

    idfilemap = {}
    InkscapeRemote.new do |inkscape|
      variants.each do |variant|
        if not File.exists? variant.image.svg_path
          raise ProcessError, "Source SVG file #{variant.image.svg_path} does not exist"
        end

        out_res = nil
        # order: 200x200, @id/area, svg res
        if variant.image.res
          out_res = variant.image.res
        elsif variant.image.area == :drawing
          res = inkscape.drawing_area(variant.image.svg_path)
          out_res = InkscapeResolution.new(res[2], res[3], "uu")
        elsif variant.image.area
          if variant.image.area.kind_of? String
            if not idfilemap.has_key? variant.image.svg_path
              idfilemap[variant.image.svg_path] = inkscape.ids(variant.image.svg_path)
            end

            if not idfilemap[variant.image.svg_path].has_key? variant.image.area
              raise ProcessError, "Unknown id \"#{variant.image.area}\" in file #{variant.image.svg_path} when exporting #{variant.out_path}"
            end

            res = idfilemap[variant.image.svg_path][variant.image.area]
            out_res = InkscapeResolution.new(res[2], res[3], "uu")
          else
            a = variant.image.area
            # x0:y0:x1:y1
            out_res = InkscapeResolution.new(a[2]-a[0], a[3]-a[1], "uu")
          end
        else
          out_res = variant.image.svg_res
        end

        scale = variant.options[:scale]
        if scale
          out_res = out_res.scale(scale)
        end

        out_res = variant.options[:res] if variant.options[:res]

        rotate = (variant.image.format == "png" and variant.options[:rotate])

        FileUtils.mkdir_p File.dirname(variant.out_path)

        name, res = inkscape.export({
          :svg_path => variant.image.svg_path,
          :out_path => variant.out_path,
          :res => out_res,
          :dpi => variant.options[:dpi],
          :format => variant.image.format,
          :area => variant.image.area,
          :rotate_scale_hack => rotate
        })

        if rotate
          tmp, width, height = temp_rotate_svg(variant.out_path, rotate, res[0].to_i, res[1].to_i)
          name, res = inkscape.export({
            :svg_path => tmp.path,
            :out_path => variant.out_path,
            :res => InkscapeResolution.new(width / 2, height / 2, "px"),
            :format => variant.image.format
          })
          tmp.close!
        end

        if name and res
          puts "#{name} #{res[0]}x#{res[1]}"
        else
          puts variant.out_path
        end
      end
    end

    return true
  end
end

class InkImage
  attr_reader :inkfile, :prefix, :variants, :suffix, :res, :format, :area

  def initialize(inkfile, opts)
    @inkfile = inkfile
    @prefix = opts[:prefix]
    variant_opts = {
      :rotate => opts[:rotate],
      :scale => opts[:scale],
      :dpi => opts[:dpi]
    }
    @variants = [InkVariant.new(self, "", variant_opts)]
    opts[:variants].each do |name, options|
      @variants << InkVariant.new(self, name, options)
    end
    @suffix = opts[:suffix]
    @res = opts[:res]
    @svg = opts[:svg]
    @format = opts[:format]
    @area = opts[:area]
  end

  def svg_path
    File.expand_path(@svg || File.basename(@prefix + @suffix, ".*") + ".svg", inkfile.svg_path)
  end

  def svg_res
    @svg_res ||= 
      begin
        doc = REXML::Document.new File.read(svg_path)
        svgattr = doc.elements.to_a("//svg")[0].attributes
        if svgattr["width"] and svgattr["height"]
          InkscapeResolution.new(svgattr["width"], svgattr["height"], "uu")
        else
          nil
        end
      end
  end
end

class InkVariant
  attr_reader :image, :name, :options

  def initialize(image, name, options)
    @image = image
    @name = name
    @options = options
  end

  def out_path
    File.expand_path(
      "#{@image.prefix}#{@name}#{@image.suffix}",
      @image.inkfile.out_path)
  end
end

$verbose = false
inkfile_path = nil
inkfile_opts = {}
OptionParser.new do |o|
  o.banner = "Usage: #{$0} [options] [Inkfile]"
  o.on("-v", "--verbose", "Verbose output") { $verbose = true }
  o.on("-s", "--svg PATH", "SVG source base path") { |v| inkfile_opts[:svg_path] = v }
  o.on("-o", "--out PATH", "Output base path") { |v| inkfile_opts[:out_path] = v }
  o.on("-f", "--force", "Force regenerate (skip time check)") { |v| inkfile_opts[:force] = true }
  o.on("-i", "--inkscape PATH", "Inkscape binary path", "Default: #{InkscapeRemote.path || "not found"}") { |v| $inkscape_path = v }
  o.on("-h", "--help", "Display help") { puts o; exit }
  begin
    inkfile_path = o.parse!.first
  rescue OptionParser::InvalidOption => e
    puts e.message
    exit 1
  end
end

inkfile_path = File.expand_path(inkfile_path || "Inkfile", Dir.pwd)

begin
  raise "Could not find Inkscape binary (maybe try --inkscape?)" if not InkscapeRemote.path
  raise "Inkscape binary #{InkscapeRemote.path} does not exist or is not executable" if not InkscapeRemote.path or not File.executable? InkscapeRemote.path
rescue StandardError => e
  puts e.message
  exit 1
end

begin
  if not InkFile.new(inkfile_path, inkfile_opts).process
    puts "Everything seams to be up to date"
  end
rescue InkFile::ProcessError, SystemCallError => e
  puts e.message
  exit 1
end

